/* Copyright (C) 2009
     National Institute of Advanced Industrial Science and Technology (AIST)
     Registration Number H15PRO112
   See the end for copying conditions.  */

/***

@page mdbTutorialIM Tutorial of input method

@section im-struct Structure of an input method file

An input method is defined in a *.mimx file with this format. 

@verbatim
<input-method xmlns="http:://www.m17n.org/MIM">
  <tags>
    <language>LANG</language>
    <name>NAME</name>
  </tags>
  <description>DESCRIPTION</description>
  <title>TITLE-STRING</title>

  <variable-list> ... </variable-list>
  <command-list> ... </command-list>
  <module-list> ... </module-list>
  <macro-list> ... </macro-list>

  <map-list>
    <map id="map-1">
      <rule>
        <keyseq keys="KEYSEQ11"/>
        ACTIONS1 ...
      </rule>
      <rule>
        <keyseq keys="KEYSEQ12"/>
        ACTIONS2 ...
      </rule>
        ...
    </map>
    <map id="map-2">
      <rule>
        <keyseq keys="KEYSEQ21"/>
        ACTIONS21 ...
      </rule>
      <rule>
        <keyseq keys="KEYSEQ22"/>
        ACTIONS22 ...
      </rule>
        ...
    </map>
        ...
  </map-list>

  <state-list>
    <state id="state-1">
      <branch branch-selecting-map="map-1">
        S-ACTIONS1
      </branch>
      <branch branch-selecting-map="map-2">
        S-ACTIONS2
      </branch>
       ....
    </state>
       ....
  </state-list>
@endverbatim

The m17n library input method driver loads an input method and,
according to the input method, translates input key sequences into
characters through some actions.

Tags should be written as they are.  Contents and attribute values
(written with uppercases here) may be restricted to some
patterns. (See m17n-db-xml/MIM/mim.rng for details.)  Every child
element but <tags> is optional and we will not see the variable-list,
command-list, module-list and macro-list in this tutorial.

<keyseq> specifies a sequence of keys in one of the following two ways.
@li one or more <key-event> (the keysym value returned by the xev command) or 
<character-code>.
@li a string that can be entered from the keyboard. (Usually only
ASCII characters.  However, if the input method is intended to be
used, for instance, with a West European keyboard, the value may
contain Latin-1 characters.)

@verbatim

  <keyseq>
   <character-code>0x2E</character-code>
   <key-event>A-z</key-event>
  </keyseq>

  <keyseq keys="egsk"/>

@endverbatim

These are both valid <keyseq>s.

Characters translated from an input sequence is temporarily put into a
special place @c preedit @c buffer.  The input method driver uses this
buffer to store, change or re-arrenge characters, and when it is done,
commit the characters in the buffer to applications.

Actions for the translation are defined in <map>s and <state>s.

ACTIONS and S-ACTIONS are a sequence of actions.  They may or may not
have attributes or contents that specify its details.  For example,
the action for character insertion takes the character to be inserted
as the value of its attribute "character", and the action for calling
external function requires the function to be called as its content.

The most common action is for inserting fixed characters or strings.
The input method driver keeps a position called the "current
position" in the preedit buffer.  The current position exists between
two characters, at the beginning of the buffer, or at the end of the
buffer.  The inserting action puts characters before the current
position.

Inserting actions are written as below.

@verbatim
      <insert string="tutirial "/>

      <insert character="0x0BB3"/>
@endverbatim

When your preedit buffer contains "this ^text" ("^" indicates the
current position), the first example change the buffer to "this
tutorial ^text".

The second example inserts a Tamil Letter LAA to the preedit buffer.

@section im-upcase A simple example: Caps lock

Here is a simple example of an input method that works as Caps Lock.

@verbatim
<input-method xmlns="http:://www.m17n.org/MIM">
  <tags>
    <language>en</language>
    <name>capslock</name>
  </tags>
  <description>Up-case all lowercase letters</description>
  <title>a->A</title>
  <map-list>
    <map id="map-to-upper">
      <rule><keyseq keys="a"/><insert string="A"/></rule>
      <rule><keyseq keys="b"/><insert string="B"/></rule>
      <rule><keyseq keys="c"/><insert string="C"/></rule>
      <rule><keyseq keys="d"/><insert string="D"/></rule>
                 :                          :
      <rule><keyseq keys="i"/><insert string="I"/></rule>
                 :                          :
      <rule><keyseq keys="x"/><insert string="X"/></rule>
      <rule><keyseq keys="y"/><insert string="Y"/></rule>
      <rule><keyseq keys="z"/><insert string="Z"/></rule>
    </map>
  </map-list>
  <state-list>
    <state id="state-init">
      <branch branch-selecting-map="map-to-upper">
      </branch>
    </state>
  </state-list>
</input-method>
@endverbatim

When an input method is activated, the input method driver is in the
initial condition of the first <state> in the <state-list>. In this
case, it is the state whose @c id is @c state-init.  In the initial
condition, no key is being processed and no action is suspended.

Each <state> has <branch>es.  <branch> has an attribute @c
branch-selecting-map and its value appears as the value of @c id
attribute of one of the <map>s.  This attribute defines the
correspondence between a <map> and a <branch>.  A <map> has <rule>s,
and a <rule> has a <keyseq>, so when a key sequence is given, a <map>
that handles the key sequence is determined, and a <branch> that is
responsible for the map is determined.

When the input method driver receives a key sequence "a", it searches
for a <rule> whose <keyseq> part matches with "a", and finds one in
the <map> whose @c id is @c map-to-upper.  The selected branch is the
one whose @c branch-selecting-map is @c map-to-upper.

When a given key sequence does not match with any <rule> in any <map>
that corresponds with a <branch> of the current <state>, that event is
unhandled and given back to the application program.

The driver then executes ACTIONs of the <rule>. In this case, it
inserts "A" in the preedit buffer.  Then S-ACTIONs in the <branch>, if
any, are executed.  When all ACTIONs and S-ACTIONs have been handled,
the driver shifts to the initial condition of the current state.

The shift to the initial condition of the first state has a special
meaning; it commits all characters in the preedit buffer and clears
it.  In this case, as the result, "A" is given to the
application program.

Turkish users may want to extend the above example for "İ" (U+0130:
LATIN CAPITAL LETTER I WITH DOT ABOVE).  Assigning the key sequence
"ii" for that character would be convenient, so and the user might add
this rule in the @c map-to-upper map.

@verbatim
      <rule><keyseq keys="ii"/><insert string="İ"/></rule>
@endverbatim

However, we already have the following rule:

@verbatim
      <rule><keyseq keys="i"/><insert string="I"/></rule>
@endverbatim

Will these rules conflict?  What will happen when a key sequence "i" is
entered?  

The input method driver takes care of these kind of overlapping rules.
When the driver receives a "i", it inserts "I" in the preedit buffer.
As it knows that there is another rule that may match the additional
key event "i", after inserting "I", it suspends the normal behavior of
shifting to the initial condition, and waits for another key. The user
will see "I" with underline, which indicates the rule for this
translation is not deterministic and the "I" is not yet committed.

When the input method driver receives the next "i", it cancels all the
effects of the rule for the previous "i".  In this case, the preedit
buffer is cleared.  Then it executes ACTIONs of the rule for "ii",
that is, inserts an "İ" to the preedit buffer.  This time, there is no
rule that matches with "ii" and an additional key, so the character is
determined, the driver shifts to the initial condition of the current
state, and the "İ" is committed.

What will happen when the next key event is not "i", but "a" ?  The
input method has no rule that matches with the "i" "a" key sequence.

When the driver receives an "a" after "i", it executes the suspended
behavior, i.e. shifting to the initial condition, which leads to
commit "I".  Then it tries to handle "a" in the current state, which
leads to commit "A".

@section im-state-action Use of state example: Capitalizing 

We have so far explained ACTIONs, but not S-ACTIONs.  The format of a
S-ACTION is the same as that of an ACTION.  It is executed only after
a matching rule has been determined and the corresponding ACTIONs have
been executed.  A typical use of S-ACTION is to shift to a different
state.

In order to see how S-ACTIONs are used, let us modify the current
input method to upcase only such letters that start a word (i.e. to
capitalize).  For this purpose, the "state-init" state should be
modified as below.

@verbatim
    <state id="state-init">
      <branch branch-selecting-map="map-to-upper">
      </branch>
      <shift-to id="state-non-upcase"/>
    </state>
@endverbatim

The S-ACTION here is &lt;shift-to&gt; that shifts the input method
driver to another state whose id is @c state-non-upcase.

We now need to define the state.  It has one branch and one catchall.

@verbatim
    <state id="state-non-upcase">
      <branch branch-selecting-map="map-lower"/>
      <catch-all-branch><shift-to id="state-init"/></catch-all-branch>
    </state>
@endverbatim

The branch is for character "a" to "z", and we need a new map with the
id "map-lower" that inserts lowercase letters as they are.

@verbatim
    <map id="map-lower">
      <rule><keyseq keys="a"/><insert string="a"/></rule>
      <rule><keyseq keys="b"/><insert string="b"/></rule>
                 :                          :
      <rule><keyseq keys="y"/><insert string="y"/></rule>
      <rule><keyseq keys="z"/><insert string="z"/></rule>
@endverbatim

The catchall branch matches with any key event that does not match any
rules in the other maps in the current state.  In this case, it
matches with characters other than [a-z].  A catchall branch does not
consume any key event.

We will show the full code of the new input method before explaining
how it works.

@verbatim
<input-method xmlns="http:://www.m17n.org/MIM">
  <tags>
    <language>en</language>
    <name>titlecase</name>
  </tags>
  <description>Titlecase letters</description>
  <title>abc->Abc</title>
  <map-list>
    <map id="map-to-upper">
      <rule><keyseq keys="a"/><insert string="A"/></rule>
      <rule><keyseq keys="b"/><insert string="B"/></rule>
                 :                          :
      <rule><keyseq keys="y"/><insert string="Y"/></rule>
      <rule><keyseq keys="z"/><insert string="Z"/></rule>
    </map>
    <map id="map-lower">
      <rule><keyseq keys="a"/><insert string="a"/></rule>
      <rule><keyseq keys="b"/><insert string="b"/></rule>
                 :                          :
      <rule><keyseq keys="y"/><insert string="y"/></rule>
      <rule><keyseq keys="z"/><insert string="z"/></rule>
    </map>
  </map-list>
  <state-list>
    <state id="state-init">
      <branch branch-selecting-map="map-to-upper">
        <shift-to id="state-non-upcase"/>
      </branch>
    </state>
    <state id="state-non-upcase">
      <branch branch-selecting-map="map-lower"><commit/></branch>
      <catch-all-branch><shift-to id="state-init"/></catch-all-branch>
    </state>
  </state-list>
</input-method>
@endverbatim

Let us see what happens when a user types the key sequence "a" "b" "
".  The driver, as usual, starts at the state @c state-init.  Upon
"a", a rule in the map @c map-to-upper matches, "A" is inserted to the
preedit buffer and the driver shifts to the state @c state-non-upcase.

The next "b" is handled in @c state-non-upcase.  It matches the
&lt;keyseq&gt; of the second &lt;rule&gt; in the map @c map-lower, so
it is handled by the &lt;branch&gt; whose @c branch-selecting-map is @c
map-lower.  By the rule in the map, "b" is &lt;inserted in the preedit
buffer and it is committed explicitly by the &lt;commit&gt; in
&lt;branch&gt;.

At this point, the input method is still in @c state-non-upcase, where
the next " " key is handled.  This time, however, the only branch in
this state has no rule for the key and &lt;catch-all-branch&gt; is
selected. S-action in this branch is to the shift to @c state-init.

Note that the key " " is not yet handled because
&lt;catch-all-branch&gt; does not consume any key event.  The input
method driver tries to handle it in @c state-init, but no rule matches
it.  Therefore, that event is given back to the application program,
which usually inserts a space for that.

When you type "a quick blown fox" with this input method, you get "A
Quick Blown Fox".  OK, you find a typo in "blown", which should be
"brown".  To correct it, you probably move the cursor after "l" and
type the Backspace key and the "r".  However, if the current input
method is still active, a capital "R" is inserted.  This is not a very
refined behavior.

@section im-surrounding-text Surrounding text support example: Capitalizing Revised

We need "surrounding text support" to make the input method work well
with such cases.  It checks and changes characters around the
inputting spot.  This facility is available only with Gtk+
applications and Qt applications, and cannot be used with applications
that utilizes XIM to communicate with an input method.

Before "surrounding text support", we explain a few features of the
input method; variables, arithmetic operations and comparisons, and
conditional actions.

As we have already seen in &lt;insert&gt; action, some actions takes
the attribute or the content that specifies the target of the action,
and some attribute or content may contain a variable as its value.

For instance, the actions

@verbatim
  <set id="X"><int-val>32</int-val></set>
  <insert character-or-string="variable"><variable-reference id="X"/></insert>
@endverbatim

set the variable @c X to integer value 32, then insert a character
whose Unicode character code is 32 (i.e. SPACE).

The variable value can be set to an integer value, another variable,
or an expression of this form:

@verbatim
  <expr operator="OPERATOR">
	EXPRESSION1
	EXPRESSION2
  </expr>
@endverbatim

EXPRESSION1 and EXPRESSION2 can also be an expression.  For example,
the action below sets the value of the variable @c X to @c Y*32+Z.

@verbatim
  <set id="X">
   <expr operator="+">
    <expr operator="*">
      <variable-reference id="Y"/><int-val>32</int-val>
    </expr>
    <variable-reference id="Z"/>
   </expr>
  </set>
@endverbatim

The operators that appear in expressions are divided into the
following three groups.

@li Arithmetic and bitwise operators that requires two arguments.

@verbatim
  + - * / & |
@endverbatim

@li Relational operators that requires two arguments.

@verbatim
  == <= >= < >
@endverbatim

@li Logical operators that requires one argument.

@verbatim
  !
@endverbatim

The input method can control the processing flow with
&lt;conditional&gt; that has the following form.

@verbatim
  <conditional>
    <case> 
       EXPRESSION1
       ACTIONs1
    </case> 
    <case> 
       EXPRESSION1
       ACTIONs1
    </case> 
     .....
  </conditional>
@endverbatim

<conditional> checks the value of EXPRESSION in <case>s one by one,
and when the <case> whose EXPRESSION has a nonzero value is
encountered, ACTIONs in that <case> are performed.

Now let us return to surrounding text support.  Some variables are
predefined and among them are @c predefined-surround-text-flag and @c
predefined-nth-previous-or-following-character whose values are
defined as below and can not be altered.

<ul>
<li> predefined-surround-text-flag

-1 if surrounding text is supported, -2 if not.

<li> predefined-nth-previous-or-following-character

This variable takes an attribute @c position whose value must be an
positive or negative integer.  If the @c position value is negative,
the value of the @c predefined-nth-previous-or-following-character is
the Nth previous character in the preedit buffer.  If there are only M
(M<N) previous characters in it, the value is the (N-M)th previous
character from the inputting spot.  If positive, the value of the @c
predefined-nth-previous-or-following-character is the Nth following
character in the preedit buffer.  If there are only M (M<N) following
characters in it, the value is the (N-M)th following character from
the inputting spot.  
</ul>

When you have the context below, where "def" is in the preedit buffer
and your current position in the preedit buffer is between "d" and "e":

@verbatim
  ABCdefGHI
@endverbatim

The @c predefined-nth-previous-or-following-character has the
following values.

@verbatim
  <predefined-nth-previous-or-following-character position="-3"/>  --> ?B
  <predefined-nth-previous-or-following-character position="-2"/>  --> ?C
  <predefined-nth-previous-or-following-character position="-1"/>  --> ?d
  <predefined-nth-previous-or-following-character position="+1"/>  --> ?e
  <predefined-nth-previous-or-following-character position="+2"/>  --> ?f
  <predefined-nth-previous-or-following-character position="+3"/>  --> ?G
@endverbatim

Now you are ready to write a new version of the input method "Titlecase".

@verbatim
<input-method xmlns="http:://www.m17n.org/MIM">
  <tags>
    <language>en</language>
    <name>Titlecase</name>
  </tags>
  <description>Titlecase letters</description>
  <title>abc->Abc</title>
  <map-list>
    <map id="map-to-upper">
      <rule><keyseq keys="a"/><insert string="A"/></rule>
      <rule><keyseq keys="b"/><insert string="B"/></rule>
                 :                          :
      <rule><keyseq keys="y"/><insert string="Y"/></rule>
      <rule><keyseq keys="z"/><insert string="Z"/></rule>
      <rule><keyseq keys="ii"/><insert string="İ"/></rule>
    </map>
  </map-list>
  <state-list>
    <state id="state-init">
      <branch branch-selecting-map="map-to-upper">

     <!-- Now that we have exactly one uppercase character in the
          preedit buffer, the element
          predefined-nth-previous-or-following-character with the
          attribute value -2 refers to the character just before the
          inputting spot. -->

      <conditional>
         <case>
           <expr operator="|">

             <!-- If The character before the inputting spot is A..Z -->
             <expr operator="&">
                <expr operator="&gt;=">
                  <predefined-nth-previous-or-following-character position="-2"/>
		  <int-val>?A</int-val></expr>
                <expr operator="&lt;=">
                  <predefined-nth-previous-or-following-character position="-2"/>
		  <int-val>?Z</int-val></expr></expr>

             <!-- or a..z -->
             <expr operator="&">
                <expr operator="&gt;=">
                  <predefined-nth-previous-or-following-character position="-2"/>
		  <int-val>?a</int-val></expr>
                <expr operator="&lt;=">
                  <predefined-nth-previous-or-following-character position="-2"/>
		  <int-val>?z</int-val></expr></expr>

             <!-- or ?İ -->
             <expr operator="=">
                <predefined-nth-previous-or-following-character position="-2"/>
		<int-val>?İ</expr>
           </expr>

	   <!-- then remember the only character in the preedit
                buffer in the variable X and delete it. -->
	   <set id="X">                
	     <predefined-nth-previous-or-following-character position="-1"/>
           </set>
           <delete-to-marker position="@first/>

           <!-	and insert the lowercase version of X. -->
           <conditional>
             <!-- If The character is ?İ, insert "i" -->
             <case>             
               <expr operator="="><variable-reference id="X"/><int-val>?İ</int-val></expr>
               <insert character="i"/>
             </case>
             <case>
               <!-- Otherwise e -->
               <int-val>1</int-val> 
               <!-- add 32 to X and insert the character, that is, insert the lowercase a-z -->
               <add id="X"><int-val>32</int-val></add>
               <insert character-or-string="variable">
               <variable-reference id="X"></insert>
             </case>
           </conditional>
        </case>
      </branch>
    </state>
  </state-list>
</input-method>

@endverbatim

The above example contains the new action &lt;delete-to-marker&gt;,
Several markers are predefined to represent (or mark) a specific
position in the preedit buffer.

&lt;delete-to-marker&gt; action takes the attribute named @c position
and its value must be a marker.  It deletes the characters between
that position and the current position.  The examples of
delete-to-marker are:

@verbatim
  <delete-to-marker position="@@previous"/> ; delete the previous character
  <delete-to-marker position="@next"/>  ; delete the next character
  <delete-to-marker position="@first"/> ; delete all the preceding characters in the buffer
  <delete-to-marker position="@last"/>  ; delete all the following characters in the buffer
@endverbatim

Let us see how our new example works.  Whatever a key event is, the
input method is in its only state, @c state-init.  Since an event of a
lower letter key falls into the branch whose @c branch-selecting-map
is @c map-to-upper and handled by &lt;rule&gt;s in that &lt;map&gt;,
the key is changed into the corresponding uppercase character and
inserted into the preedit buffer.  Now this uppercase character can be
accessed with @c position="@previous".

How can we tell whether the new character should be left as an
uppercase or changed back to a lowercase?  We need to check the
character before.  That character can be accessed by
&lt;predefined-nth-previous-or-following-character position="-2"/&gt;.

The character is checked by the @c EXPRESSION part of the &lt;case&gt;
in the first &lt;conditional&gt; of the branch for @c map-to-upper. It
is the disjunction of three <expr>s; each becomes true when the
character is between A to Z, between a to z, or İ.

When the character is not one of the above, the @c EXPRESSION does not
have a nonzero value and @c ACTIONs in this &lt;case&gt; will not be
executed.  As there is no more &lt;case&gt; in this
&lt;conditional&gt;, nothing is done to the new character in the
preedit.

When the @c EXPRESSION becomes true, the new character must be changed
into a lowercase.  @c ACTIONs part in &lt;case&gt; does the work.

Since the uppercase character is already in the preedit buffer, we
retrieve and remember it in the variable "X" with

@verbatim
  <set id="X">                
     <predefined-nth-previous-or-following-character position="-1"/>
  </set>
@endverbatim

and then delete it with

@verbatim
     <delete-to-marker position="@first/>
@endverbatim

The preedit buffer is now empty, and we re-insert the character in its
lowercase form.  The problem here is that "İ" must be changed into
"i", so we need another nested conditional.  Its first &lt;case&gt;

@verbatim
    <case>             
       <expr operator="="><variable-reference id="X"/><int-val>?İ</int-val></expr>
       <insert character="i"/>
    </case>
@endverbatim

insert "i" if the value of the variable @c X is "İ". 

The @c EXPRESSION part of the second &lt;case&gt; is 

@verbatim
    <int-val>1</int-val> 
@endverbatim

which is always resolved into nonzero, so this is the catchall.

Its @c ACTIONs part

@verbatim
   <add id="X"><int-val>32</int-val></add>
   <insert character-or-string="variable">
       <variable-reference id="X"></insert>
@endverbatim

first increases the "X" value by 32, and insert "X".  In other words,
it changes A...Z into a...z respectively and inserts the lowercase
character into the preedit buffer.  

Now the input method reaches the end of the S-ACTIONs, the character
in the preedit buffer is committed.

This new input method always checks the character before the current
position, so "A Quick Blown Fox" will be successfully fixed to "A
Quick Brown Fox" by the key sequence of a BackSpace and a "r".


*/

/* 
Copyright (C) 2007-2009
  National Institute of Advanced Industrial Science and Technology (AIST)
  Registration Number H15PRO112

This file is part of the m17n database; a sub-part of the m17n
library.

The m17n library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public License
as published by the Free Software Foundation; either version 2.1 of
the License, or (at your option) any later version.

The m17n library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the m17n library; if not, write to the Free
Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.
*/
