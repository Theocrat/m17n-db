/* Copyright (C) 2009
     National Institute of Advanced Industrial Science and Technology (AIST)
     Registration Number H15PRO112
   See the end for copying conditions.  */

/***

@page mdbTutorialIM Tutorial of input method

@section im-struct Structure of an input method file

An input method is defined in a *.mimx file with this format. 

@verbatim
<input-method xmlns="http:://www.m17n.org/MIM">
  <tags>
    <language>LANG</language>
    <name>NAME</name>
  </tags>
  <description>DESCRIPTION</description>
  <title>TITLE-STRING</title>

  <variable-list> ... </variable-list>
  <command-list> ... </command-list>
  <module-list> ... </module-list>
  <macro-list> ... </macro-list>

  <map-list>
    <map mname="MAP-1">
      <rule>
        <keyseq>INPUT_KEYS11</keyseq>
        ACTIONS11 ...
      </rule>
      <rule>
        <keyseq>INPUT_KEYS12</keyseq>
        ACTIONS12 ...
      </rule>
        ...
    </map>
    <map mname="MAP-2">
      <rule>
        <keyseq>INPUT_KEYS21</keyseq>
        ACTIONS21 ...
      </rule>
      <rule>
        <keyseq>INPUT_KEYS22</keyseq>
        ACTIONS22 ...
      </rule>
    </map>
        ...
  </map-list>

  <state-list>
    <state sname="STATE-1">
      <state-hook> HOOK ACTONS </state-hook>
      <branch mname="MAP-1">
        ACTIONS1
      </branch>
      <branch mname="MAP-2">
        ACTIONS2
      </branch>
       ....
      <catch-all-branch> CATCH-ALL ACTIONS </catch-all-branch>
    </state>
       ....
  </state-list>
@endverbatim

The m17n library input method driver loads an input method and,
according to the input method, translates input key sequences into
characters through some actions.

Tags should be written as they are.  Contents and attribute values
(written with uppercases here) may be restricted to some
patterns. (See m17n-db-xml/MIM/mim.rng for details.)  Every child
element but &lt;tags&gt; is optional. We will not see the variable-list,
command-list, module-list and macro-list in this tutorial.

Input sequence is translated into characters according to the &lt;rule&gt;s
in the &lt;map&gt;s and actions in the &lt;state&gt;s.  The characters are
temporarily put into a special place called @c preedit @c buffer.  The
input method driver uses this buffer to store, change or re-arrenge
characters, and when it is done, commit the characters in the buffer
to applications.

&lt;rule&gt; consists of a &lt;keyseq&gt; that triggers the rule and actions to
apply to the characters in the preedit buffer.

&lt;keyseq&gt; specifies a sequence of keys in one of the following two
ways.  

@li a list of &lt;symbol&gt;s or &lt;integer&gt;s.  A variable that refers
to a &lt;integer&gt;, or a function call that returns a &lt;symbol&gt; or a
&lt;integer&gt; can also appear as an element of the list.  A symbol
specifies a key event (the keysym value returned by the xev command)
and an integer specifies a character-code.

@li a string that can be entered from the keyboard. (Usually only
ASCII characters.  However, if the input method is intended to be
used, for instance, with a West European keyboard, the value may
contain Latin-1 characters.)

@verbatim

  <keyseq><list>
       <integer>0x2E</integer>
       <symbol>A-z</symbol>
  </list></keyseq>

  <keyseq><string>egsk</string></keyseq>

@endverbatim

These are both valid &lt;keyseq&gt;s.

Actions for the translation are defined in &lt;map&gt;s and &lt;state&gt;s.

Actions are a sequence of &lt;funcall&gt;.  They may or may not have
contents that specify its details.  For example, the action for
character insertion takes the character to be inserted as its content,
the action for calling external function requires the function to be
called as its content, and the action to commit the translated
characters requires no content.

The most common action is for inserting fixed characters or strings.
The input method driver keeps a position called the "current
position" in the preedit buffer.  The current position exists between
two characters, at the beginning of the buffer, or at the end of the
buffer.  The inserting action puts characters before the current
position.

Here is two examples of inserting actions:

@verbatim
      <insert><string>tutorial</string></insert>

      <insert><interger>0x0BB3</integer></insert>
@endverbatim

When your preedit buffer contains "this text" and the current position
is between the space and the second "t", the first example change the
buffer to "this tutorial text" and the current position is between the
second space and fourth "t".

The second example inserts a Tamil Letter LAA to the preedit buffer.

@section im-upcase A simple example: Caps lock

Here is a simple example of an input method that works as Caps Lock.

@verbatim
<input-method xmlns="http:://www.m17n.org/MIM">
  <tags>
    <language>en</language>
    <name>capslock</name>
  </tags>
  <description>Up-case all lowercase letters</description>
  <title>a->A</title>
  <map-list>
    <map mname="map-to-upper">
      <rule><keyseq><string>a</string></keyseq><insert><string>A</string></insert></rule>
      <rule><keyseq><string>b</string></keyseq><insert><string>B</string></insert></rule>
      <rule><keyseq><string>c</string></keyseq><insert><string>C/string></insert></rule>
                 :                          :
      <rule><keyseq><string>i</string></keyseq><insert><string>I</string></insert></rule>
                 :                          :
      <rule><keyseq><string>x</string></keyseq><insert><string>X</string></insert></rule>
      <rule><keyseq><string>y</string></keyseq><insert><string>Y</string></insert></rule>
      <rule><keyseq><string>z</string></keyseq><insert><string>Z</string></insert></rule>
    </map>
  </map-list>
  <state-list>
    <state sname="state-init">
      <branch mname="map-to-upper"/>
    </state>
  </state-list>
</input-method>
@endverbatim

When an input method is activated, the input method driver is in the
initial condition of the first &lt;state&gt; in the &lt;state-list&gt;. In this
case, it is the state whose @c mname is @c state-init.  In the initial
condition, no key is being processed and no action is suspended.

Each &lt;state&gt; has &lt;branch&gt;es.  Each &lt;branch&gt; has an attribute @c mname
that defines the correspondent &lt;map&gt;.  A &lt;map&gt; has &lt;rule&gt;s, and a
&lt;rule&gt; has a &lt;keyseq&gt;, so when a key sequence is given, a &lt;rule&gt; for
the key sequence is determined, a &lt;map&gt; that contains the rule is
determined, and a &lt;branch&gt; that is responsible for the map is
determined.

When the input method driver receives a key sequence "a", it searches
for a &lt;rule&gt; whose &lt;keyseq&gt; part matches with "a", and finds one in
the &lt;map&gt; whose @c mname is @c map-to-upper.  The selected branch is
the one whose @c mname is @c map-to-upper.

When a given key sequence does not match with any &lt;rule&gt; in any &lt;map&gt;
that corresponds with a &lt;branch&gt; of the current &lt;state&gt;, that event is
unhandled and given back to the application program.

The driver then executes actions of the &lt;rule&gt;. In this case, it
is 
@verbatim
<insert><string>A</string></insert></rule>
@endverbatim
that inserts an "A" in the preedit buffer.  Then actions in the
<branch&gt;, if any, are executed.  When all actions in the rules and the
branch have been handled, the driver shifts to the initial condition
of the current state.

The shift to the initial condition of the first state has a special
meaning; it commits all the characters in the preedit buffer and
clears it.  In this case, as the result, "A" is given to the
application program.

Turkish users may want to extend the above example for "İ" (U+0130:
LATIN CAPITAL LETTER I WITH DOT ABOVE).  Assigning the key sequence
"ii" for that character would be convenient, so the user might add
this rule in the @c map-to-upper map.

@verbatim
      <rule><keyseq><strign>ii</string><insert><string>İ</string></insert></rule>
@endverbatim

However, we already have the following rule:

@verbatim
      <rule><keyseq><strign>i</string><insert><string>I</string></insert></rule>
@endverbatim

Won't these rules conflict?  What will happen when a key sequence "i"
is entered?

The input method driver takes care of these kind of overlapping rules.
When the driver receives a "i", it inserts an "I" in the preedit
buffer.  As it knows that there is another rule that may match the
additional key event "i", after inserting "I", it suspends the normal
behavior of shifting to the initial condition, and waits for another
key.  The user will see "I" with underline, which indicates the rule
for this translation is not deterministic and the "I" is not yet
committed.

When the input method driver receives the next "i", it cancels all the
effects of the rule for the previous "i".  In this case, the preedit
buffer is cleared.  Then it executes actions of the rule for "ii",
that is, inserts an "İ" to the preedit buffer.  This time, there is no
rule that matches with "ii" and an additional key, so the character is
determined, the driver shifts to the initial condition of the current
state, and the "İ" is committed.

What will happen when the next key event is not "i", but "a" ?  The
input method has no rule that matches with the "i" "a" key sequence.

When the driver receives an "a" after "i", it executes the suspended
behavior, i.e. shifting to the initial condition, which leads to
commit "I".  Then it tries to handle "a" in the current state, which
leads to commit "A".

@section im-state-action Use of state example: Capitalizing 

We have so far explained actions in &lt;rule&gt;s, but not in &lt;branch&gt;s.
Actions in &lt;branch&gt;s are executed only after a matching rule has been
determined its actions have been executed.  A typical use of action in
a &lt;branch&gt; is to shift to a different state.

In order to see how actions in a &lt;branch&gt; are used, let us modify the
current input method to upcase only such letters that start a word
(i.e. to capitalize).  For this purpose, the "state-init" state should
be modified as below.

@verbatim
    <state sname="state-init">
      <branch mname="map-to-upper"/>
      <shift><symbol>state-non-upcase</symbol></shift>
    </state>
@endverbatim

The action in &lt;state&gt; here is &lt;shift&gt; that shifts the input method
driver to another state whose sname is @c state-non-upcase.  Let us
define the state.  It has one branch and one catchall.

@verbatim
    <state sname="state-non-upcase">
      <branch mname="map-lower"/>
      <catch-all-branch><shift><symbol>state-init</symbol></shift></catch-all-branch>
    </state>
@endverbatim

The branch is for character "a" to "z", and we need a new map with the
mname "map-lower" that inserts lowercase letters as they are.

@verbatim
    <map id="map-lower">
      <rule><keyseq><string>a</string></keyseq><insert><string>a</string></insert></rule>
      <rule><keyseq><string>b</string></keyseq><insert><string>b</string></insert></rule>
                 :                          :
      <rule><keyseq><string>z</string></keyseq><insert><string>z</string></insert></rule>
@endverbatim

The catchall branch matches with any key event that does not match any
rules in any other maps in the current state.  In this case, it
matches with characters other than [a-z].  A catchall branch does not
consume key event.

We will show the full code of the new input method before explaining
how it works.

@verbatim
<input-method xmlns="http:://www.m17n.org/MIM">
  <tags>
    <language>en</language>
    <name>titlecase</name>
  </tags>
  <description>Titlecase letters</description>
  <title>abc->Abc</title>
  <map-list>
    <map mname="map-to-upper">
      <rule><keyseq><string>a</string></keyseq><insert><string>A</string></insert></rule>
      <rule><keyseq><string>b</string></keyseq><insert><string>B</string></insert></rule>
                 :                          :
      <rule><keyseq><string>y</string></keyseq><insert><string>Y</string></insert></rule>
      <rule><keyseq><string>z</string></keyseq><insert><string>Z</string></insert></rule>
    </map>
    <map mname="map-lower">
      <rule><keyseq><string>a</string></keyseq><insert><string>a</string></insert></rule>
      <rule><keyseq><string>b</string></keyseq><insert><string>b</string></insert></rule>
                 :                          :
      <rule><keyseq><string>y</string></keyseq><insert><string>y</string></insert></rule>
      <rule><keyseq><string>z</string></keyseq><insert><string>z</string></insert></rule>
    </map>
  </map-list>
  <state-list>
    <state sname="state-init">
      <branch mname="map-to-upper">
        <shift><symbol>state-non-upcase</symbol></shift>
      </branch>
    </state>
    <state sname="state-non-upcase">
      <branch mname="map-lower"><commit/></branch>
      <catch-all-branch><shift><symbol>state-init</symbol></shift></catch-all-branch>
    </state>
  </state-list>
</input-method>
@endverbatim

Let us see what happens when a user types the key sequence "a" "b" "
".  The driver, as usual, starts at the state @c state-init.  Upon
"a", a rule in the map @c map-to-upper matches, "A" is inserted to the
preedit buffer and the driver shifts to the state @c state-non-upcase.

The next "b" is handled in @c state-non-upcase.  It matches the
&lt;keyseq&gt; of the second &lt;rule&gt; in the map @c map-lower, so
it is handled by the &lt;branch&gt; whose @c mname is @c map-lower.
By the rule in the map, "b" is inserted in the preedit buffer and it
is committed explicitly by the &lt;commit&gt; in the &lt;branch&gt;.

At this point, the input method is still in @c state-non-upcase, where
the next " " key is handled.  This time, however, the only branch in
this state has no rule for the key and &lt;catch-all-branch&gt; is
selected.  The action in this branch is to the shift to @c state-init.

Note that the key " " is not yet handled because
&lt;catch-all-branch&gt; does not consume any key event.  The input
method driver tries to handle it in @c state-init, but no rule matches
it.  Therefore, that event is given back to the application program,
which usually inserts a space for that.

When you type "a quick blown fox" with this input method, you get "A
Quick Blown Fox".  OK, you find a typo in "blown", which should be
"brown".  To correct it, you probably move the cursor after "l" and
type the Backspace key and the "r".  However, if the current input
method is still active, a capital "R" is inserted.  This is not a very
refined behavior.

@section im-surrounding-text Surrounding text support example: Capitalizing Revised

We need "surrounding text support" to make the input method work well
with such cases.  It checks and changes characters around the
inputting spot.  This facility is available only with Gtk+
applications and Qt applications, and cannot be used with applications
that utilizes XIM to communicate with an input method.

Before "surrounding text support", we explain a few features of the
expressions used in input methods; variables, arithmetic operations
and comparisons, and conditional actions.

As we have already seen in &lt;insert&gt; action, an action may use
its content to specify the target, and some content can be a variable
reference or function call.

For instance, the actions

@verbatim
  <set vname="X"><integer>32</integer></set>
  <insert><varref vname="X"></insert>
@endverbatim

set the variable @c X to integer value 32, then insert a character
whose Unicode character code is 32 (i.e. SPACE).

The variable value can be set to any term.  Terms contain, in addtion
to other items, integer values, variable references and function
calls. (See EXPR.txt for the definition of &lt;term&gt;.)  For example,
the action below contains two variable references and two function calls
and sets the value of the variable @c X to @c Y*32+Z.

@verbatim
  <set id="X">
   <add>
    <mul><varref vname="Y"/><integer>32</integer></mul>
    <varref vname="Z"/>
   </add>
  </set>
@endverbatim

&lt;mul&gt; and &lt;add&gt; here, in addiotn to others, are calls to predefined
functions.  Predefined functions include arithmetic and bitwise
operators (add, subtract, etc.) , relational operators (equal to,
greater than, etc.), logical operators (and, not, etc.), list
operators (append, nth, etc.) and control structures (loop, cond,
etc.)  EXPR.txt gives the complete list and descriptions of predefined
functions.

The input method can control the processing flow with &lt;cond&gt;
that has the following form.

@verbatim
  <cond>
    <list>EXPRESSION1 ACTIONs1 </list>
    <list>EXPRESSION2 ACTIONs2 </list>
     .....
  </cond>
@endverbatim

&lt;cond&gt; checks the value of EXPRESSION in &lt;list&gt;s one by one, and when
the &lt;list&gt; whose EXPRESSION has a nonzero value is encountered,
ACTIONs in that &lt;list&gt; are performed.

Now let us return to surrounding text support.  Calls to the
predefined function &lt;surround-text-flag&gt; returns -1 if surrounding
text is supported, and -2 if not.

In order to know what characters surrounds the input spot, we need the
help of &lt;marker&gt; and &lt;char-at&gt;.  &lt;marker&gt; indicates a position in the
buffer and the predefined function &lt;char-at&gt; returns the character at
the specified position.  

&lt;marker&gt;@@+N&lt;/marker&gt; and &lt;marker&gt;@@-N&lt;marker&gt; (N is an positive
integer) mark the N-th preceding or following position, and are used
to specify a character inside or outside of the preedit buffer.  If
the number of preceding or following characters in the preedit buffer
is less than N, it marks the (N minus the number of characters)th
preceding or following character from the input spot.

When you have the context below, where "def" is in the preedit buffer
and your current position in the preedit buffer is between "d" and "e":

@verbatim
  ABCdefGHI
@endverbatim

The calls to the &lt;char-at&gt; functions return the following values.

@verbatim
  <char-at><marker>-3</marker></char-at>  --> ?B
  <char-at><marker>-2</marker></char-at>  --> ?C
  <char-at><marker>-1</marker></char-at>  --> ?d
  <char-at><marker>+1</marker></char-at>  --> ?e
  <char-at><marker>+2</marker></char-at>  --> ?f
  <char-at><marker>+3</marker></char-at>  --> ?G
@endverbatim

Now we are ready to write a new version of the input method
"Titlecase".

@verbatim
<input-method xmlns="http:://www.m17n.org/MIM">
  <tags>
    <language>en</language>
    <name>Titlecase</name>
  </tags>
  <description>Titlecase letters</description>
  <title>abc->Abc</title>
  <map-list>
    <map mname="map-to-upper">
      <rule><keyseq><string>a</string></keyseq><insert><string>A</string></insert></rule>
      <rule><keyseq><string>b</string></keyseq><insert><string>B</string></insert></rule>
                 :                          :
      <rule><keyseq><string>y</string></keyseq><insert><string>Y</string></insert></rule>
      <rule><keyseq><string>z</string></keyseq><insert><string>Z</string></insert></rule>
      <rule><keyseq><string>ii</string></keyseq><insert><string>İ</string></insert></rule>
    </map>
  </map-list>
  <state-list>
    <state sname="state-init">
      <branch mname="map-to-upper">

     <!-- Now that we have exactly one uppercase character in the
          preedit buffer, <char-at><marker>-2</marker></char-at>
          returns the character just before the inputting spot. -->

      <cond>
         <list>
           <or>

             <!-- If The character before the inputting spot is A..Z -->
             <and>
                <gt><char-at><marker>-2</marker></char-at>
                    <integer>?A</integer></gt> 
                <lt><char-at><marker>-2</marker></char-at>
                    <integer>?Z</integer></lt> 
             </and>

             <!-- or a..z -->
             <and>
                <gt><char-at><marker>-2</marker></char-at>
                    <integer>?a</integer></gt> 
                <lt><char-at><marker>-2</marker></char-at>
                    <integer>?z</integer></lt> 
             </and>

             <!-- or ?İ -->
             <eq><char-at><marker>-2</marker></char-at><integer>?İ</integer></eq>
           </or>

	   <!-- then remember the only character in the preedit
                buffer in the variable X and delete it. -->
	   <set vname="X"><char-at><marker>-1</marker></char-at></set>
           <delete><marker>@<</marker></delete>

           <!-	and insert the lowercase version of X. -->
           <cond>
             <!-- If The character is ?İ, insert "i" -->
             <list>             
               <eq><varref vname="X"/><integer>?İ</integer></eq>
               <insert><string>i</string></insert>
             </list>
             <list>
               <!-- Otherwise  -->
               <integer>1</integr> 
               <!-- add 32 to X and insert the character, that is, insert the lowercase a-z -->
               <add vname="X"><integer>32</integer></add>
               <insert><varref vname="X"/></insert>
             </list>
           </cond>
        </list>
       </cond>
      </branch>
    </state>
  </state-list>
</input-method>

@endverbatim

The above example contains the new action &lt;delete&gt;, Several
markers are predefined to mark a specific position in the preedit
buffer.  When the content of &lt;delete&gt; is a marker, a function call to
the &lt;delete&gt; deletes the characters between the marked position and
the current position.  The examples are:

@verbatim
  <delete><marker>@-</marker></delete> ; delete the previous character
  <delete><marker>@+</marker></delete> ; delete the next character
  <delete><marker>@<</marker></delete> ; delete the character between the current position
                                       ; and the first position of the buffer, that is, 
                                       ; delete all the preceding characters in the buffer
  <delete><marker>@></marker></delete> ; delete the character between the current position
                                       ; and the last position of the buffer, that is, 
                                       ; delete all the following characters in the buffer
@endverbatim

Let us see how our new example works.  Whatever a key event is, the
input method is in its only state, @c state-init.  Since an event of a
lower letter key falls into the branch whose @c mname is @c
map-to-upper and handled by &lt;rule&gt;s in that &lt;map&gt;, the key
is changed into the corresponding uppercase character and inserted
into the preedit buffer.  Now this uppercase character can be accessed
with &lt;char-at&gt;&lt;marker&gt;-1&lt;/marker&gt;&lt;/char-at&gt;.

How can we tell whether the new character should be left as an
uppercase or changed back to a lowercase?  We need to check the
character before.  That character can be accessed by
&lt;char-at&gt;&lt;marker&gt;-2&lt;/marker&gt;&lt;/char-at&gt;.

The character is checked by the @c EXPRESSION part of the &lt;list&gt;
in the first &lt;cond&gt; of the branch for @c map-to-upper. It is the
disjunction of three conditons; each becomes true when the character
is between A to Z, between a to z, or İ.

When the character is not one of the above, @c ACTIONs in this
&lt;list&gt; will not be executed.  As there is no more &lt;list&gt;
in this &lt;cond&gt;, nothing is done to the new character in the
preedit.

When the @c EXPRESSION becomes true, the new character must be changed
into a lowercase, and @c ACTIONs part does the work.  Since the
uppercase character is already in the preedit buffer, we retrieve and
remember it in the variable "X" with

@verbatim
    <set vname="X"><char-at><marker>-1</marker></char-at></set>
@endverbatim

and then delete it with

@verbatim
      <delete><marker>@<</marker></delete>
@endverbatim

The preedit buffer is now empty, and we re-insert the character in its
lowercase form.  The problem here is that "İ" must be changed into
"i", so we need another nested conditional.  Its first &lt;list&gt;

@verbatim
       <list>             
          <eq><varref vname="X"/><integer>?İ</integer></eq>
          <insert><string>i</string></insert>
       </list>
@endverbatim

insert "i" if the value of the variable @c X is "İ". 

The @c EXPRESSION part of the second &lt;list&gt; is 

@verbatim
    <integer>1</integer> 
@endverbatim

which is always resolved into nonzero, so this is the catchall.

Its @c ACTIONs part

@verbatim
      <add vname="X"><integer>32</integer></add>
      <insert><varref vname="X"/></insert>
@endverbatim

first increases the "X" value by 32, and insert "X".  In other words,
it changes A...Z into a...z respectively and inserts the lowercase
character into the preedit buffer.  

Now that the input method reaches the end of the acions in the branch,
the character in the preedit buffer is committed.

This new input method always checks the character before the current
position, so "A Quick Blown Fox" will be successfully fixed to "A
Quick Brown Fox" by the key sequence of a BackSpace and a "r".


*/

/* 
Copyright (C) 2007-2009
  National Institute of Advanced Industrial Science and Technology (AIST)
  Registration Number H15PRO112

This file is part of the m17n database; a sub-part of the m17n
library.

The m17n library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public License
as published by the Free Software Foundation; either version 2.1 of
the License, or (at your option) any later version.

The m17n library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the m17n library; if not, write to the Free
Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.
*/
