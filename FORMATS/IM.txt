/* Copyright (C) 2003, 2004, 2005, 2009
     National Institute of Advanced Industrial Science and Technology (AIST)
     Registration Number H15PRO112
   See the end for copying conditions.  */

/***en

@page mdbIM Input Method

@section im-description DESCRIPTION

The m17n library provides a driver for input methods that are
dynamically loadable from the m17n database (see @ref m17nInputMethod
@latexonly (P.\pageref{group__m17nInputMethod}) @endlatexonly).

This section describes the data format that defines those input
methods.

@section im-format SYNTAX and SEMANTICS

The following defines a schema for an input method, written in
RelaxNG.  (This schema file can be found at
m17n-db-xml/MIMNEW/mimnew.rng and includes m17n-db-xml/MIMNEW/expr.rng
that defines basic expressions and terms.)

@verbatim

<?xml version="1.0" encoding="utf-8"?>

<grammar 
	 datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
         xmlns:xi="http://www.w3.org/1999/XML/xinclude"
	 xmlns="http://relaxng.org/ns/structure/1.0"
	 ns="http://www.m17n.org/MIM">

<include href="expr.rng"/>

<start>
  <element name="input-method">
    <ref name="im-declaration"/>
    <ref name="description"/>

    <optional><element name="title"><data type="string"/></element></optional>
    <optional><ref name="variable-list"/></optional>
    <optional><ref name="command-list"/></optional>
    <optional><ref name="module-list"/></optional>
    <optional><ref name="macro-list"/></optional>

    <optional><ref name="map-list"/></optional>
    <optional><ref name="state-list"/></optional>
  </element>
</start>

@endverbatim

The top-level node of an input method has a &lt;input-method&gt; tag.
The element &lt;im-declaration&gt; is described in the subsection @ref
im-declaration.

Details of &lt;description&gt; can be found in @ref expr. 

The element &lt;title&gt; contains a string that is displayed on the
screen when this input method is active.

#if EXAMPLE_CODE
<input-method xmlns="http://www.m17n.org/MIM">
  <tags>
    <language>bo</language>
    <name>ewts</name>
  </tags>
  <description>Tibetan input method based on EWTS.
This implementation is based on THDL Extended Wylie Transliteration Scheme
Version 2.0 &lt;http://www.thdl.org/collections/langling/ewts/ewts.php&gt;.</description>
  <title>ཀ</title>
      :       :
#endif

&lt;variable-list&gt;, &lt;command-list&gt;, &lt;module-list&gt; and
&lt;macro-list&gt; declares variables, commands, external modules, and
macros used in this input method, respectively.  The input method can
contain variables that are not declared in &lt;variable-list&gt;, but
other elements have to list up all the items.

&lt;map-list&gt; declares maps used in an input method.  When an input
method is never standalone and always included in another method, the
element &lt;map-list&gt; can be omitted.  &lt;state-list&gt; declares
states used in an input method.  When an input system is never
standalone and always included in another system, the element
&lt;state-list&gt; can be omitted.
    
@subsection im-declarations Input Method Declaration

@verbatim

<define name="im-declaration">
  <element name="tags">
    <element name="language">
      <choice>
	<value>t</value>
	<data type="string"><param name="pattern">[a-z]{2,3}</param></data>
      </choice>
    </element>
  <choice>
    <group>
      <element name="name"><value>nil</value></element>
      <element name="extra-id"><data type="ID"/></element>
    </group>
    <group>
      <element name="name">
	<choice>
	  <data type="string"><param name="pattern">[^n][^i][^l]</param></data>
	  <data type="string"><param name="pattern">.{1,2}</param></data>
	  <data type="string"><param name="pattern">....+</param></data>
	</choice>
      </element>
      <optional><element name="extra-id"><data type="ID"/></element></optional>
    </group>
  </choice>
  </element>
  <optional>
    <element name="m17n-version">
      <data type="string"><param name="pattern">[0-9]+\.[0-9]+\.[0-9]+</param></data>
    </element>
  </optional>
</define>

@endverbatim

The element &lt;tags&gt; specifies for which language the input method
is, and the name of the input method. There is one special input
method file "global.mimx" that declares common variables and commands.
The input method driver always loads this file and other input methods
can inherit its variables and commands.

When the element &lt;language&gt; has "t" as its content, the use of the
input method is not limited to one language.  When the content is
other than "t", it must be a valid code in ISO639-1, two-character
code or ISO639-2, three character code for the names of languages.

When the element &lt;name&gt; has "nil" as its content, the input method is
not standalone, but is expected to be used in other input methods.  In
such cases, the element &lt;extra-id&gt; is required to identify the input
method.  When the element &lt;name&gt; has content other than "nil", the
element &lt;extra-id&gt; is optional.

#if EXAMPLE_CODE
  <tags>
    <language>bo</language>
    <name>ewts</name>
  </tags>
#endif

#if EXAMPLE_CODE
  <tags>
    <language>t</language>
    <name>nil</name>
    <extra-id>zh-util</extra-id>
  </tags>
#endif

The optional element &lt;m17n-version&gt; specifies the required minimum
version number of the m17n library.  The format is "X.Y.Z" where X is
a major version number, Y is a minor version number, and Z is a patch
level.

@subsection im-setups Input Method Setups

@verbatim

<define name="variable-list">
  <element name="variable-list">
    <oneOrMore>
      <ref name="defvar"/>
    </oneOrMore>
  </element>
</define>

@endverbatim

&lt;variable-list&gt; declares variables used in this input method.  
Details of &lt;defvar&gt; can be found in @ref expr.

If a variable is initialized to the default value, or a common
variable from "global.mimx" is to be customized by a user, it must be
declared here.  In other words, a variable can appear without this
declaration unless it has a default value or its possible values are
limited.

The declaration can be used in two ways.  One is to introduce a new
variable.  In such case &lt;defvar&gt; must specify its value.  The
other is to inherit the variable from what declared in "global.mimx",
and to give the different default value and/or to make the variable
customizable specially for the current input method.  In this case,
the value can be omitted.

#if EXAMPLE_CODE
  <variable-list>
    <defvar vname="precomposed">
      <description>
        <get-text>Flag to tell whether or not to generate precomposed characters.
                  If 1, generate precomposed characters if available (e.g. "ྲྀ"(U+0F76).
                  If 0, generate only decomposed characters (e.g. "ྲྀ" (U+0FB2 U+0F80).</get-text>
      </description>
      <integer>0</value>
      <possible-value>
        <integer>0</value>
        <integer>1</value>
      </possible-value>
    </defvar>
  </variable-list>
#endif

This code declares a variable "precomposed" whose possible values are
integer 0 or 1 and the default value is 0.

@verbatim
<define name="command-list">
  <element name="command-list">
    <oneOrMore>
      <element name="defcmd">
	<attribute name="cname">
	  <data type="ID"><param name="pattern">command-.*</param></data></attribute>
	<optional>
	  <ref name="description"/>
	</optional>
	<zeroOrMore><ref name="keyseq"/></zeroOrMore>
      </element>
    </oneOrMore>
  </element>
</define>

<define name="keyseq">
  <element name="keyseq">
    <oneOrMore>
      <choice>
	<ref name="strterm"/>
	<ref name="listterm"/>
      </choice>
      </oneOrMore>
  </element>
</define>
@endverbatim

&lt;command-list&gt; declares a command used in the input method.  If a
command must be bound to the default key sequence, or is to be
customized by a user, it must be declared here.  
Each &lt;defcmd&gt; declares one command.  A command is referred with
the attribute "cname" whose value must start with "command-".
&lt;keyseq&gt; contains one or more list/string terms.

Like &lt;variable-list&gt;, the declaration can be used in two ways.
One is to introduce a new command.  In that case, the &lt;keyseq&gt;
element must appear in &lt;defcmd&gt;.  Another is to inherit the
command from what declared in "global.mimx", and to give the different
key binding and/or to make the command customizable specially for the
current input method.  In the latter case, &lt;keyseq&gt; can be
omitted.


#if EXAMPLE_CODE
   <command-list>
    <defcmd cname="command-commit">
      <description>
        <get-text>Commit
Commit the preedit text</get-text>
      </description>
      <keyseq><list><symbol>Return</symbol></list></keyseq>
      <keyseq><list><symbol>Linefeed</symbol></list></keyseq>
    </defcmd>
   </command-list>
#endif

@verbatim
<define name="module-list">
  <element name="module-list">
    <oneOrMore>
      <element name="module">
	<attribute name="id"><data type="string"/></attribute>
	<oneOrMore>
	  <element name="defun">
	    <attribute name="fname">
	      <data type="ID"><param name="pattern">.*-function-.*</param></data>
	    </attribute>
	    <empty/>
	  </element>
	</oneOrMore>
      </element>
    </oneOrMore>
  </element>
</define>
@endverbatim

Each &lt;module&gt; element declares an external module (i.e. dynamic
library).  The value of "id" attribute gives the name of the module.

&lt;defun&gt; elements specify function names exported by the module.
The name of the module, "-function-" and the name of the function
itself consitute the value of the "fname" attribute.  If the "fname"
attribute has the value that ends with "init", it is called with only
the default arguments when an input context is created for the input
method.  If it has the value that ends with "fini", it is called with
only the default arguments when the input context is destroyed.

#if EXAMPLE_CODE
  <module-list>
    <module id="libmimx-anthy">
      <defun fname="libmimx-anthy-function-convert"/>
      <defun fname="libmimx-anthy-function-resize"/>
      <defun fname="libmimx-anthy-function-change"/>
      <defun fname="libmimx-anthy-function-commit"/>
      <defun fname="libmimx-anthy-function-init"/>
      <defun fname="libmimx-anthy-function-fini"/>
    </module>
  </module-list>
#endif

This code declares a module "libmimx-anthy" that exports six functions.

Functions of an external modules can be called with the element
&lt;funcall&gt;.  The function must return NULL or a list that
represents &lt;funcall&gt;s to execute.

#if EXAMPLE_CODE
    <funcall fname="libmimx-anthy-function-resize">
       <symbol>t</symbol>
    </funcall>
#endif

This code calls the function 'resize' of the module 'libmimx-anthy'
with a symbol argument whose value is "t".

@verbatim
<define name="macro-list">
  <element name="macro-list">
    <oneOrMore>
      <ref name="defun"/>
    </oneOrMore>
  </element>
</define>
@endbatim

&lt;macro-list&gt; declares macros used in this input method.  Details
of &lt;defun&gt; can be found in @ref expr.


#if EXAMPLE_CODE
  <macro-list>
    <defun fname="macro-delete-preceding-zw">
      <cond>
        <list>
          <logior>
            <eq><char-at><marker>@-1</marker></char-at><integer>0x200C</integer></eq>
            <eq><char-at><marker>@-1</marker></char-at><integer>0x200D</integer></eq>
          </logior>
          <delete><marker>@-1</marker></delete>
          <funcall fname="macro-delete-preceding-zw"/>
        </list>
      </cond>
    </defun>
  </macro-list>

#endif

This code declares one macro "macro-delete-preceding-zw".


@subsection im-terms Input Method Terms

The m17n database has special terms for wrinting input methods:
markers, selectors and key sequences.

@verbatim
<define name="term" combine="choice">
  <choice>
    <ref name="keyseq"/>
    <ref name="marker"/>
    <ref name="selector"/>
  </choice>
</define>
@endverbatim

These terms can be used in functions defined in mimnew.rng.

@verbatim
<define name="marker">
  <element name="marker"><data type="string"/></element>
</define>
@endverbatim

A marker is a symbol indicating a character position in the preediting
buffer.  The element &lt;mark&gt; assigns a position to a marker.  The
position of a marker is referred by the elements &lt;move&gt;,
&lt;delete&gt; and &lt;char-at&gt;.

Some markers that starts with @@ have special meanings.  @@0, @@1,
... , @@9 mark the 0th, 1st, ... , 9th position in the preedit buffer
respectively.  @@&lt;, @@=, @@&gt;, @@- and @@+ mark the first,
current, last, preceding and following position in the preediting buffer
respectively.  @@[ marks the preceding position where a candidate list
changes.  @@] marks the next position where a candidate list changes.

@@+N and @@-N (N is an positive integer) mark the N-th preceding or
following position, and are used to specify a character inside or
outside of the preedit buffer.
If the number of preceding or following
characters in the preedit buffer is less than N, it marks the (N minus
the number of characters)th preceding or following character from the
input spot.

Other marker should not start with @@. 

#if EXAMPLE_CODE
 <delete><marker>@&lt;<marker></delete>
#endif

This code deletes character between the first position and the current
position in the buffer.

#if EXAMPLE_CODE
 <move><marker>T</marker></move>
#endif

This code moves the marker to the user defined position T.

#if EXAMPLE_CODE
  <char-at><marker>@-5</marker></char-at>
#endif

This code refers to the 5th preceding character wherever it is.

@verbatim
<define name="markerterm">
  <choice>
    <ref name="marker"/>
    <ref name="funcall"/>
    <ref name="varref"/>
  </choice>
</define>
@endverbatim

A &lt;markerterm&gt; is a term whose value is a marker.  That is, if a
&lt;varref&gt; appears as a &lt;markerterm&gt;, its value must be a
marker and a &lt;funcall&gt; appears as a &lt;markerterm&gt;, it must
return a marker.

@verbatim
<define name="selector">
  <element name="selector">
    <choice>
	<value>@first</value>
	<value>@current</value>
	<value>@last</value>
	<value>@previous</value>
	<value>@next</value>
	<value>@previous-candidate-change</value>
	<value>@next-candidate-change</value>
    </choice>
  </element>
</define>
@endverbatim

Selectors specify positions in a candidate list. They are used in the
element &lt;select&gt;.  @first, @current and @last specifies the
first, the current and last position in the list.  @@previous means
the previous position, and if the current candidate is the first one
in the current candidate group, this value means the last candidate in
the previous candidate group.  @@next means the next position, and if
the current candidate is the last one in the current candidate group,
this value means the first candidate in the next candidate group.
@@previous_candidate_list specifies the candidate in the previous
candidate group having the same candidate index as the current one,
and @@next_candidate_list specifies the candidate in the next
candidate group having the same candidate index as the current one.

&lt;select&gt; accepts an integer, too.  An integer N specifies the
Nth position in a candidate list.

#if EXAMPLE_CODE
  <select><selector>@previous</selector></select>
#endif

This code selects the previous candidate.

@verbatim
<define name="selectorterm">
  <choice>
    <ref name="selector"/>
    <ref name="funcall"/>
    <ref name="varref"/>
  </choice>
</define>
@endverbatim

A &lt;selectorterm&gt; is a term whose value is a selector.  That is,
if a &lt;varref&gt; appears as a &lt;selectorterm&gt;, its value must
be a selector and a &lt;funcall&gt; appears as a &lt;selectorterm&gt;,
it must return a selector.

@verbatim
<define name="keyseq">
  <element name="keyseq">
    <oneOrMore>
      <choice>
	<ref name="strterm"/>
	<ref name="listterm"/>
      </choice>
      </oneOrMore>
  </element>
</define>
@endverbatim

&lt;strterm&gt in the &lt;keyseq&gt; element consists of characters
that can be generated by a keyboard.  Therefore it usually contains
only ASCII characters.  However, if the input method is intended to be
used, for instance, with a West European keyboard, the value may
contain Latin-1 characters.

The element in the &lt;listterm&gt in the &lt;keyseq&gt; must be
either an &lt;intterm&gt; whose value is a valid character code, or a
&lt;symterm&gt; whose value is the return value of the
minput_event_to_key () function.  Under the X window system, you can
quickly check the value using the @c xev command.  For example, the
return key, the backspace key, and the 0 key on the keypad are
represented as @c Return, @c BackSpace, @c KP_0 respectively.  If the
shift, control, meta, alt, super, and hyper modifiers are used, they
are represented by the S- , C- , M- , A- , s-, and H- prefixes
respectively in this order.  Thus, "return with shift with meta with
hyper" is @c S-M-H-Return.  Note that "a with shift" .. "z with shift"
are represented simply as A .. Z.  Thus "a with shift with meta with
hyper" is @c M-H-A.


#if EXAMPLE_CODE
<keyseq>
   <list>
      <integer>0x6F</integer>
      <symbol>S-@</symbol>
   </list>
</keyseq>

<keyseq><string>ma</string></keyseq>
#endif

These are both valid key sequences.

@verbatim
<define name="keyseqterm">
  <choice>
    <ref name="keyseq"/>
    <ref name="funcall"/>
    <ref name="varref"/>
  </choice>
</define>
@endverbatim

A &lt;keyseqterm&gt; is a term whose value is a keyseq.  That is, if a
&lt;varref&gt; appears as a &lt;keyseqterm&gt;, its value must be a
keyseq and a &lt;funcall&gt; appears as a &lt;keyseqterm&gt;, it
must return a keyseq.

@subsection immap Input Method Maps and Rules

@verbatim
<define name="map-list">
 <element name="map-list">
  <oneOrMore>
    <element name="map">
      <attribute name="mname">
	<data type="ID"><param name="pattern">map-.*</param></data>
      </attribute>
      <zeroOrMore>
	<element name="rule">
	  <choice>
	    <ref name="keyseq"/>
	    <ref name="command-reference"/>
	  </choice>
	  <zeroOrMore><ref name="funcall"/></zeroOrMore>
	</element>
      </zeroOrMore>
    </element>
  </oneOrMore>
 </element>
</define>

@endverbatim

&lt;map-list&gt; declares maps used in this input method.  The element
&lt;map&gt; bundles and names a set of similar &lt;rule&gt;s, so that
&lt;state&gt; transitions can be clearly defined.  The attribute
"mname" gives the name of a &lt;map&gt;.

The element &lt;rule&gt; defines the mapping of an input key sequence
&lt;keyseq&gt; (or &lt;command-reference&gt;) and functions the input
method driver should call. For example, a rule may make the input
method insert an appropriate character upon receiving a particluar
input keys.


#if EXAMPLE_CODE
  <map-list>
    <map mname="map-consonant">
      <rule><keyseq><string>k</string></keyseq><insert><string>ཀ</string></insert></rule>
      <rule><keyseq><string>kh</string></keyseq><insert><string>ཁ</string></insert></rule>
          :         :
      <rule><keyseq><string>a</string></keyseq><insert><string>ཨ</string></insert></rule>
    </map>
    <map mname="map-standard-stack">
           :         :
    </map>
           :         :
  </map-list>
#endif

@verbatim

<define name="command-reference">
  <element name="command">
      <attribute name="cname"><data type="IDREF"/></attribute>
  </element>
</define>

@endverbatim

The element &lt;command-reference&gt; has the same effect as the
&lt;keyseq&gt; defined in the &lt;defcmd&gt; that has the same "cname"
value would have, if appeared in its place.

#if EXAMPLE_CODE
<command-reference cname="command-start"/>
#endif

This code calls the command "command-start".

@subsection imfuncalls Input Method Functions

In addion to those defined in expr.rng, the m17n database prepares
several functions for writing input methods.  

@verbatim
<define name="funcall" combine="choice">
  <choice>
    <element name="insert"><choice><ref name="intterm"/><ref name="strterm"/></choice></element>
@endverbatim

The element &lt;insert&gt; inserts a character or a M-text before the
current position.  
When its content is a &lt;strterm&gt;, its value is the M-text to be inserted.
When an &lt;intterm&gt; is given, its value is the code of a character to be
inserted.
The marker positions affected by the insertion are
automatically relocated.

#if EXAMPLE_CODE
<insert><string>á</string></insert>
<insert><integer>225</integer></insert>
<insert><integer>0x00E1</integer></insert>
#endif

These codes insert the same character "á".

@verbatim
    <element name="insert-candidates">
      <oneOrMore><choice><ref name="listterm"/><ref name="strterm"/></choice></oneOrMore>
    </element>
@endverbatim

The element &lt;insert-candidates&gt; specifies characters or strings
to be possibly inserted before the current position. 

When a &lt;listterm&gt; is glven, each item in this list is a
candidate string to be inserted.  When a &lt;strterm&gt; is given,
each character in the string is a candidate character to be inserted.
&lt;insert-candidates&gt; inserts the first candidate before the current
position.  The inserted character or string is associated with the
list of candidates and the information indicating the currently
selected candidate.


#if EXAMPLE_CODE
<insert><string>＄￠￡￥￦</string></insert>

<insert><list>
	 <string>a</string>
	 <string>ā</string>
	 <string>á</string>
	 <string>ǎ</string>
	 <string>à</string>
</list></insert>
#endif

These codes insert "＄", and "a" respectively and associate the whole list
of five items with it.

@verbatim
    <element name="delete"><choice><ref name="markerterm"/><ref name="intterm"/></choice></element>
@endverbatim

When a &lt;markerterm&gt; is given, this element deletes characters between
the current position and the specified marker position.

#if EXAMPLE_CODE
<delete><marker>@-</marker></delete>
#endif

This code deletes the character between the current position and the
preceding position.

When a &lt;intterm&gt; is given, the element &lt;delete&gt; treats it as a
character position, and deletes characters between the current
position and the character position.

The marker positions affected by the element &lt;delete&gt;s are
automatically relocated.

@verbatim
    <element name="select"><choice><ref name="selectorterm"/><ref name="intterm"/></choice></element>
@endverbatim

The element &lt;select&gt; first checks if the string just before the
current position belongs to a string that is associated with a
candidate list.  If so, it replaces that string with a candidate
specified by the &lt;selectorterm&gt; or the &lt;intterm&gt;.  If a
&lt;intterm&gt; is given, it specifies a position in the candidate
list.

#if EXAMPLE_CODE
<select><selector>@first</selector></select>
<select><integer>0</integer></select>
#endif

Both of these codes select the first candidate in the list.

@verbatim
    <element name="show-candidates"><empty/></element>
@endverbatim

The element &lt;show-candidates&gt; instructs the input method driver to
display a candidate list associated with the string before the current
position. 

@verbatim
    <element name="hide-candidates"><empty/></element>
@endverbatim

The element &lt;hide-candidates&gt; instructs the input method driver to
hide the currently displayed candidate list.

@verbatim
    <element name="move"><choice><ref name="markerterm"/><ref name="intterm"/></choice></element>
@endverbatim

The element &lt;move&gt; moves the current position.  When a
&lt;markerterm&gt; is given, the current position is moved to the position of
the marker.  When an &lt;intterm&gt; is given, its value is a character
position and the current position is moved to the character postion.

#if EXAMPLE_CODE
<move><marker>@@&lt</marker></move>
<move><integer>0</integer></move>
#endif

Both of these codes move the current position to the first position in
the buffer.

@verbatim
    <element name="mark"><ref name="markerterm"/></element>
@endverbatim

The element &lt;mark&gt; puts a specified marker to the current
position.

#if EXAMPLE_CODE
<mark><marker>M</marker></mark>
#endif

This code sets the marker "M" to the current position.

@verbatim
    <element name="pushback"><choice><ref name="keyseqterm"/><ref name="intterm"/></choice></element>
@endverbatim

The element &lt;pushback&gt; pushes back key events to the event
queue.  When a &lt;keyseqterm&gt; is given, it pushes back specified keys.  An
&lt;intterm&gt; given to this element must not be negative.  If it is zero,
all key events are pushed back.  If it is a positive integer N, the
latest N key events are pushed back.

#if EXAMPLE_CODE
<pushback><keyseq>b</keyseq></pushback>
#endif

This code pushes back a "b".

@verbatim
    <element name="pop"><empty/></element>
@endverbatim

The element &lt;pop&gt; pops the first key event that is not yet handled
from the event queue.

@verbatim
    <element name="undo"><optional><ref name="intterm"/></optional></element>
@endverbatim

The element &lt;undo&gt; cancels the last two key events (i.e. the one
that invoked this command, and the previous one) when it has no
content.  An intterm given to this element must not be zero.  If its
value is a positive integer N, from the Nth to the last events are
canceled.  If its value is a negative integer -N, the last N events
are canceled.

#if EXAMPLE_CODE
<undo><integer>-1</integer></undo>
#endif

This code cancels the last event.

@verbatim
    <element name="commit"><empty/></element>
@endverbatim

The element &lt;commit&gt; explicitly commits the current preedit.
The current preedit is also committed whenever the input method driver
transits to the intial &lt;state&gt;.  (See @ref imstate.)

@verbatim
    <element name="unhandle"><empty/></element>
@endverbatim

The element &lt;unhandle&gt; commits the current preedit and returns the last key as
unhandled. 

@verbatim
    <element name="shift"><ref name="symterm"/></element>
    <element name="shiftback"><empty/></element>
@endverbatim

The element &lt;shift&gt; shifts the current state (See @ref imstate.)
to the one specified by the value of the given &lt;symterm&gt;.  The value
must appear in &lt;state-list&gt;.  The element &lt;shiftback&gt;
shifts the current state to the previous one.

@verbatim
    <element name="char-at"><ref name="markerterm"/></element>
@endverbatim

The element &lt;char-at&gt; returns the integer value
&lt;integer&gt;C&lt;/integer&gt;, where C is the character in the preedit text or
the surrounding text at the postion specified by the given &lt;markerterm&gt;.

@verbatim
    <element name="key-count"><empty/></element>
@endverbatim

The element &lt;key-count&gt; returns the integer value
<integer>N</integer>, where N is the number of currently handled keys

@verbatim
    <element name="surrounding-text-flag"><empty/></element>

  </choice>
</define>
@endverbatim

&lt;surrounding-text-flag&gt; returns &lt;integer&gt;1&lt;/integer&gt;
if surrounding text handling is supported or
&lt;integer&gt;0&lt;/integer&gt; if not.


@subsection imstate Input Method States and Transitions

@verbatim
      
<define name="state-list">
  <element name="state-list">
    <zeroOrMore>
      <element name="state">
	<attribute name="sname">
	  <data type="ID"><param name="pattern">state-.*</param></data>
	</attribute>
	<optional><element name="title"><data type="string"/></element></optional>
	<interleave>
	<optional>
	  <element name="state-hook">
	    <oneOrMore><ref name="funcall"/></oneOrMore>
	  </element>
	</optional>
	<optional>
	  <element name="catch-all-branch">
	    <zeroOrMore><ref name="funcall"/></zeroOrMore> 
	  </element>
	</optional>
	<zeroOrMore>
	  <element name="branch">
	    <attribute name="mname">
		<data type="IDREF"/>
	    </attribute>
	    <zeroOrMore><ref name="funcall"/></zeroOrMore>
	  </element>
	</zeroOrMore>
	</interleave>
      </element>
    </zeroOrMore>
  </element>
</define>

@endverbatim

The input method driver is always in one of the &lt;state&gt;s of an
&lt;input-method&gt; and may transit to another &lt;state&gt; when
processing an input.  The same input sequence can trigger different
&lt;funcall&gt;s and produce different results in different
&lt;state&gt;s.

The attribute "sname" gives the name of a &lt;state&gt;.  The element
&lt;title&gt; in the &lt;state&gt; element specifies a title text
displayed on the screen when the input method is in this state.  When
this element is omitted, the content of the &lt;title&gt; element in
the &lt;input-method&gt; used instead.

When an input context is created, i.e. the input method is invoked,
the input method driver is in the first &lt;state&gt; of the
&lt;state-list&gt;.

Each &lt;state&gt; has zero or more &lt;branch&gt;es.  Each
&lt;branch&gt; corresponds to a &lt;map&gt; in a &lt;map-list&gt;
whose "mname" value is the same with the branch's "mname" value.  When
the input sequence matches one of the &lt;keyseq&gt; (or
&lt;command-reference&gt;) of a &lt;rule&gt; of the &lt;map&gt;, the
corresponding &lt;branch&gt; is selected.  The input method driver
first executes &lt;funcall&gt;s in the &lt;rule&gt;, then
&lt;funcall&gt;s specified in that &lt;branch&gt;, and shifts to the
initial condition of the current state.

Whenever the input method driver shifts to the initial condition of
the first &lt;state&gt;, it commits all characters in the preedit
buffer and clears the preedit buffer, without explicit call to
&lt;commit&gt;.

Optional element &lt;state-hook&gt; specifies &lt;funcall&gt;s
executed when the input method driver is shifted to the current
&lt;state&gt;.  Remember that when an input context of the input
method is created, the input method is "shifted" to the first
&lt;state&gt; in the &lt;state-list&gt; element, and the
&lt;funcall&gt;s in the &lt;state-hook&gt; of the first &lt;state&gt;
will be executed.

When an input sequence does not match with any of the &lt;branch&gt;s in the current &lt;state&gt;,
   @li If the &lt;catch-all-branch&gt; element exists,
      &lt;funcall&gt;s in the &lt;catch-all-branch&gt; is executed.
   @li If there is no &lt;catch-all-branch&gt; element,
     the input method transits to the initial state.

#if EXAMPLE_CODE

  <state-list>
    <state sname="state-init">
      <branch mname="map-consonant">
        <shift><symbol>state-second</symbol></shift>
      </branch>
      <branch mname="map-independent"/>
    </state>
    <state sname="state-second">
      <branch mname="map-underscore">
        <shift><symbol>state-init</symbol></shift>
      </branch>
      <branch mname="map-dependent">
        <shift><symbol>state-init</symbol></shift>
      </branch>
      <branch mname="map-ry"/>
    </state>
  </state-list>
#endif

This code defines state transitions in an input method.  It has two
states "state-init" and "state-second".  The state "state-init" has
two &lt;branchglt;s corresponding to "map-consonant" and
"map-independent".  When an input sequence belonging to
"map-consonant" is given, the state is shifted to "state-second",
after executing &lt;funcall&gt;s in the &lt;rule&gt; for the input
sequence.  The state "state-second" has three branches, two of which
shift the state back to the "state-init".

@verbatim
</grammar>
@endverbatim

The RelaxNG schema for a input method closes with &lt;/grammar&gt;.

@ifnot FOR-MAN

@section im-example1 EXAMPLE 1

This is a very simple example for inputting Latin characters with
diacritical marks (acute and cedilla).  For instance, when you type:
@verbatim
    Comme'die-Franc,aise, chic,,
@endverbatim
you will get this:
@if FOR-HTML
@verbatim
    Commédie-Française, chic,
@endverbatim
@endif
@if FOR-LATEX
@latexonly
\hskip5mm\texttt{\footnotesize Comm\'{e}die-Fran\c{c}aise, chic,}
@endlatexonly
@endif

The definition of the input method is very simple as below, and it is
quite straightforward to extend it to cover all Latin characters.

@verbatim
<?xml version='1.0'?>
<input-method xmlns="http://www.m17n.org/MIM">
  <tags>
    <language>t</language>
    <name>latn-post</name>
  </tags>
  <title>latin-postfix</title>
  <map-list>
    <map mname="map-trans">
      <rule><keyseq><string>A</string><keyseq><insert><string>Á</string></insert></rule>
      <rule><keyseq><string>a'</string></keyseq><insert><string>á</string></insert></rule>
      <rule><keyseq><string>A''</string></keyseq><insert><string>A'</string></insert></rule>
      <rule><keyseq><string>a''</string></keyseq><insert><string>a'</string></insert></rule>
      <rule><keyseq><string>C,</string></keyseq><insert><string>Ç</string></insert></rule>
      <rule><keyseq><string>c,</string></keyseq><insert><string>ç</string></insert></rule>
      <rule><keyseq><string>C,,</string></keyseq><insert><string>C,</string></insert></rule>
      <rule><keyseq><string>c,,</string></keyseq><insert><string>c,</string></insert></rule>
      <rule><keyseq><string>E'</string></keyseq><insert><string>É</string></insert></rule>
      <rule><keyseq><string>e'</string></keyseq><insert><string>é</string></insert></rule>
      <rule><keyseq><string>E''</string></keyseq><insert><string>E'</string></insert></rule>
      <rule><keyseq><string>e''</string></keyseq><insert><string>e'</string></insert></rule>
      <rule><keyseq><string>I'</string></keyseq><insert><string>Í</string></insert></rule>
      <rule><keyseq><string>i'</string></keyseq><insert><string>í</string></insert></rule>
      <rule><keyseq><string>I''</string></keyseq><insert><string>I'</string></insert></rule>
      <rule><keyseq><string>i''</string></keyseq><insert><string>i'</string></insert></rule>
      <rule><keyseq><string>O'</string></keyseq><insert><string>Ó</string></insert></rule>
      <rule><keyseq><string>o'</string></keyseq><insert><string>ó</string></insert></rule>
      <rule><keyseq><string>O''</string></keyseq><insert><string>O'</string></insert></rule>
      <rule><keyseq><string>o''</string></keyseq><insert><string>o'</string></insert></rule>
      <rule><keyseq><string>U'</string></keyseq><insert><string>Ú</string></insert></rule>
      <rule><keyseq><string>u'</string></keyseq><insert><string>ú</string></insert></rule>
      <rule><keyseq><string>U''</string></keyseq><insert><string>U'</string></insert></rule>
      <rule><keyseq><string>u''</string></keyseq><insert><string>u'</string></insert></rule>
    </map>
  </map-list>
  <state-list>
    <state sname="state-init">
      <branch mname="map-trans"/>
    </state>
  </state-list>
 </input-method>
@endverbatim


@section im-example2 EXAMPLE 2

This example is for inputting Unicode characters by typing C-u
(Control-u) followed by four hexadecimal digits.  For instance, when
you type ("^u" means Control-u):
@verbatim
    ^u2190^u2191^u2192^u2193
@endverbatim
you will get this (Unicode arrow symbols):
@if FOR-LATEX
@verbatim
    $\leftarrow \uparrow \rightarrow \downarrow
@endverbatim
@endif
@if FOR-HTML
@verbatim
    ←↑→↓
@endverbatim
@endif

The definition utilizes <set> and <if> as below:
@verbatim
<?xml version='1.0'?>
<input-method xmlns="http://www.m17n.org/MIM">
  <tags>
    <language>t</language>
    <name>unicode</name>
  </tags>
  <title>UNICODE</title>
  <map-list>
    <map mname="map-starter">
      <rule><keyseq><list><symbol>C-U</symbol></list></keyseq><insert><string>U+</string></insert></rule>
    </map>
    <map mname="map-hex">
      <rule><keyseq><string>0<string></keyseq><insert><string>0</string></insert></rule>
      <rule><keyseq><string>1</string></keyseq><insert><string>1</string></insert></rule>
                   :                            :
      <rule><keyseq><string>9</string></keyseq><insert><string>9</string></insert></rule>
      <rule><keyseq><string>A</string></keyseq><insert><string>A</string></insert></rule>
      <rule><keyseq><string>B</string></keyseq><insert><string>B</string></insert></rule>
                   :                             :
      <rule><keyseq><string>f</string></keyseq><insert><string>F</string></insert></rule>
    </map>
  </map-list>
  <state-list>
    <state sname="state-init">
      <branch mname="map-starter">
        <set vname="code"><integer>0</integer></set>
        <set vname="count"><integer>0</integer></set>
        <shift><symbol>state-unicode</symbol></shift>
      </branch>
    </state>
    <state sname="state-unicode">
      <branch mname="map-hex">
        <set vname="this"><char-at><marker>@-</marker></char-at></set>
        <if>
          <lt><varref vname="this"/><integer>65</integer></lt>  <!-- ?A -->
          <progn>
            <sub vname="this"><integer>48</integer></sub>
          </progn>
          <progn>
            <sub vname="this"><integer>55</integer></sub>
          </progn>
        </if>
        <mul vname="code"><integer>16</integer></mul>
        <add vname="code"><varref vname="this"/></add>
        <add vname="count"><integer>1</integer></add>
        <if>
          <eq><varref vname="count"/><integer>4</integer></eq>
          <progn>
            <delete><marker>@&lt;</marker></delete>
            <insert><varref vname="code"/></insert>
            <shift><symbol>state-init</symbol></shift>
          </progn>
        </if>
      </branch>
    </state>
  </state-list>
</input-method>

@endverbatim

@section im-example3 EXAMPLE 3

This example is for inputting Chinese characters by typing PinYin key
sequence.
@if FOR-HTML
For instance, when you type:
@verbatim
    nihaobei2jing2
@endverbatim
you will get:
@verbatim
    你好北京
@endverbatim

The definition uses <insert-candidates> to show characters of a same
pronunciation and <select> to choose one of them.  Note that this is
just an example, and it ignores such important key as Backspace.

@verbatim
<input-method> <tags>..</tags>
<title>"拼"</title>

<map-list>
  <map mname="map-starter"> 
<!-- The initial character of Pinyin.-->
     <rule><keyseq><string>a</string></keyseq></rule>
     <rule><keyseq><string>b</string></keyseq></rule>
          :                 :
     <rule><keyseq><string>z</string></keyseq></rule>
  </map>
  <map mname="map-pinyon">
<!-- Big table of Pinyin vs the corresponding Chinese characters.-->
     <rule><keyseq><string>bei</string></keyseq>
           <insert-candidates><string>被北备背悲辈杯倍贝碑... </string>>...</insert-candidates></rule>	
     <rule><keyseq><string>hao</string></keyseq>
           <insert-candidates><string>好号毫豪浩耗皓嚎昊郝... </string>>...</insert-candidates></rule>
     <rule><keyseq><string>jing</string></keyseq>
           <insert-candidates><string>经京精境警竟静惊景敬... </string>>...</insert-candidates></rule>	
     <rule><keyseq><string>ni</string></keyseq>
           <insert-candidates><string>你呢尼泥逆倪匿拟腻妮... </string>>...</insert-candidates></rule>	
  </map>
  <map id="map-choose">
<!-- Typing 1, 2, ..., 0 selects the 0th, 1st, ..., 9th candidate.-->
      <rule><keyseq><string>1</string><select><integer>0</integer></select></rule>
      <rule><keyseq><string>2</string><select><integer>1</integer></select></rule>
           :                     :
      <rule><keyseq><string>9</string><select><integer>8</integer></select></rule>
      <rule><keyseq><string>0</string><select><integer>9</integer></select></rule>
  </map>
</map-list>

<state-list>
   <state sname="state-init">
<!--  When an initial character of Pinyin is typed, re-handle it in 
     "state-main" state.  Anything else is just produced as is. -->
     <branch mname="map-starter">
        <show-candidates/>
        <pushback><integer>1</integer></pushback>
        <shift><symbol>state-main</symbol></shift>
     </branch>
   </state>

   <state sname="state-main">
<!--   When a complete Pinyin sequence is typed, shift to "state-select" state
       to allow users to select one from the candidates.   -->
      <branch mname="map-pinyin">
        <shift><symbol>state-select</symbol></shift>
      </branch>
<!--   When anything else is typed, produce the current candidate (if
       any), and re-handle the last input in "state-init" state. -->
      <catch-all-branch>
        <hide-candidates/>
        <shift><symbol>state-init</symbol></shift>
      </catch-all-branch>
   </state>

   <state id="state-select">
<!-- When a number is typed, select the corresponding canidate,
     produce it, and shift to "init" state. -->
       <branch mname="map-choose">
        <hide-candidates/>
        <shift><symbol>state-init"</symbol></shift>
       </branch>

<!-- When anything else is typed, produce the current candidate,
     and re-handle the last input in "init" state. -->
      <catch-all-branch>
        <hide-candidates/>
        <shift><symbol>state-init</symbol></shift>
      </catch-all-branch>
   </state>
 </state-list>
</input-method>

@endverbatim

@elseif FOR-LATEX
@latexonly
\begin{center}
\fbox{This example is readable only in the documentation of HTML version.}
\end{center}
@endlatexonly
@endif

@endif

@section im-seealso SEE ALSO

@ref mim-list "Input Methods provided by the m17n database",
@ref mdbGeneral "mdbGeneral(5)"
*/

/* 
Copyright (C) 2003, 2004, 2005
  National Institute of Advanced Industrial Science and Technology (AIST)
  Registration Number H15PRO112

This file is part of the m17n database; a sub-part of the m17n
library.

The m17n library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public License
as published by the Free Software Foundation; either version 2.1 of
the License, or (at your option) any later version.

The m17n library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the m17n library; if not, write to the Free
Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.
*/

/* Local Variables: */
/* coding: utf-8 */
/* End: */


